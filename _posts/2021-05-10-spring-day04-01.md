---

layout: post
title:  "Junit 4 & Spring Test을 이용한 TDD 환경 세팅"
date: 2021-05-11 09:00:21 +0900
categories: JAVA Lecture

---

![img](https://blog.kakaocdn.net/dn/0k7OA/btq4s2NKn16/9nK6amTJW7f1FeINbEmsJ1/img.png)

# Junit 4 & Spring Test을 이용한 TDD 환경 세팅



## 프레젠테이션 계층의 구현과 테스트



#### 학습 목표 : WAS를 직접 실행하지 않고 Controller를 테스트할 수 있다. (WAS에 의존적이지 않다.)



## 1. Controller의 작성

스프링 MVC의 Controller는 하나의 클래스 내에서 여러 메서드를 작성하고, @RequestMapping 등을 이용해서 URL을 분기하는 구조로 작성할 수 있기 때문에 하나의 클래스에서 필요한 만큼 메서드의 분기를 이용하는 구조로 작성한다.



과거에는 이 단계에서 Tomcat(WAS)를 실행하고 웹 화면을 만들어서 결과를 확인하는 방식의 코드를 작성해 왔다. 이 방식은 시간도 오래 걸리거니와 테스트를 자동화 하기에 어려움이 많다.



##### 1-1. BoardController 분석 (기획)



작성하기 전에는 반드시 현재 원하는 기능을 호출하는 방식에 대해 다음과 같이 테이블로 정리한 후 코드를 작성하는 것이 좋다.



|   TASK   |       URL       | Method         | Parameter | Form | URL  |
| :------: | :-------------: | -------------- | --------- | ---- | ---- |
| 전체목록 |   /board/list   | GET 방식 처리  | -         | -    | -    |
| 등록처리 | /board/register | POST 방식 처리 | 모든 항목 | 필요 | 이동 |
|   조회   |   /board/read   | GET 방식 처리  | bno       | -    | -    |
| 삭제처리 |  /board/remove  | GET 방식 처리  | bno       | -    | -    |
| 수정처리 |  /board/modify  | POST 방식 처리 | 모든 항목 | 필요 | 이동 |

테이블에서 From 항목은 해당 URL을 호출하기 위해서 별도의 입력화면이 필요하다는 것을 의미한다. 이에 대한 설계는 화면을 구성하는 단계에서 진행할 수 있다.

----



`BaordController.java` 컨트롤러 작성



```java
package com.koreait.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.koreait.service.BoardService;

import lombok.AllArgsConstructor;
import lombok.extern.log4j.Log4j;

@Controller
@Log4j
@AllArgsConstructor // 생성자로 service 주입 
@RequestMapping("/board/*")
public class BoardController {
	
	private BoardService service;
	
}
```

- BoardController는 @Controller 어노테이션을 추가해서 스프링의 빈으로 인식할 수 있게 하고, @RequestMapping을 통해서 '/board'로 시작하는 모든 처리를 BoardController가 하도록 지정한다. BoardController가 속한 org.zerock.controller 패키지는 servlet-context.xml에 기본으로 설정되어 있으므로 별도의 설정이 필요하지 않다. 

  (Java 설정을 이용하는 경우에는 @ComponentScan을 이용)





##### 2-1. 목록에 대한 처리와 리스트

###### 2-1-1. BoardController에서 전체 목록을 가져오는 처리를 먼저 작성한다. BoardController는 BoardService 타입의 객체와 같이 연동해야 하므로 의존성에 대한 처리도 같이 진행한다.



```java
package com.koreait.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import com.koreait.service.BoardService;

import lombok.AllArgsConstructor;
import lombok.extern.log4j.Log4j;

@Controller
@Log4j
@AllArgsConstructor // 생성자로 service 주입 
@RequestMapping("/board/*")
public class BoardController {
	
	private BoardService service;
	
	@GetMapping("/list")
	public void list(Model model) {
		log.info("list");
		model.addAttribute("list",service.getList());
	}

}
```



oardController 는 BoardService에 대해서 의존적이므로 @AllArgsConstructor를 이용해서 생성자를 만들고 자동으로 주입하도록 한다. (만일 생성자를 만들지 않을 경우에는 @Setter(onMethod_ = {@Autowired}) 를 이용해서 처리한다.)

 

list()는 나중에 게시물의 목록을 전달해야 하므로 Model을 파라미터로 지정하고, 이를 통해서 BoardServiceImpl 객체의 getList() 결과를 담아 전달한다. (=addAttribute) BoardController 테스트는 스프링의 테스트 기능을 통해서 확인해 볼 수 있다.

 

###### 2-1-2. src/test/java 에 org.zerock.controller 패키지에 BoardControllerTests 클래스를 선언한다.



![img](https://blog.kakaocdn.net/dn/TNdAI/btqAAFs6pGo/vMgr2c8aTWBsxBZJOeoQ7k/img.png)



 

테스트 코드는 기존과 좀 다르게 진행된다. 그 이유는 웹을 개발할 때 매번 URL을 테스트하기 위해서 Tomcat과 같은 WAS를 실행하는 불편한 단계를 생략하기 위해서다. 스프링의 테스트 기능을 활용하면 개발 당시에 Tomcat(WAS)를 실행하지 않고도 스프링과 웹 URL을 테스트할 수 있다.

 

WAS를 실행하지 않기 위해서는 약간의 추가적인 코드가 필요하지만 반복적으로 서버를 실행하고 화면에 입력하고, 오류를 수정하는 단계를 줄여줄 수 있기 때문에 Controller를 테스트할 때는 한 번쯤 고려해 볼 만한 방식이다. 





###### 2-1-3. BoardControllerTests 클래스에 다음과 같은 코드를 작성한다.



```java
package com.koreait.controller;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import lombok.Setter;
import lombok.extern.log4j.Log4j;

@RunWith(SpringJUnit4ClassRunner.class)
@WebAppConfiguration   // Servlet의 ServletContext를 이용하기 위함
@ContextConfiguration({
   "file:src/main/webapp/WEB-INF/spring/root-context.xml",
   "file:src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml"
})
@Log4j
public class BoardControllerTests {
   @Setter(onMethod_ = @Autowired)
   private WebApplicationContext wac;
   
   // 가짜 MVC
   // 마치 브라우저에서 사용하는 것처럼 만들어서 Controller를 실행해 볼 수 있다.
   private MockMvc mockMvc; // 주입을 받는게 아니라 wac를 통해서 build 하는 것
   
   @Before   // org.JUnit, 모든 테스트 전에 실행되는 어노테이션
   public void setup() {
      // WebApplicationContext를 통해 ServletContext를 빌드한다.
      // builder가 아니고 builder"s"
      this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); 
   }
   
   @Test
   public void testList() throws Exception{
      log.info(mockMvc.perform(MockMvcRequestBuilders.get("/board/list"))   // 여기서 get은 GET방식
               .andReturn()
               .getModelAndView()
               .getModelMap());   // model을 Map으로 바꿔준다.
   }
}
```

테스트 클래스의 선언부에는 @WebAppConfiguration 어노테이션을 적용한다. @WebAppConfiguration은 Servlet의 ServletContext를 이용하기 위해서인데, 스프링에서는 WebApplicationContext라는 존재를 이용하기 위해서이다. 

 

@Before 어노테이션이 적용된 setUp()에서는 import 할 때 JUnit을 이용해야 한다. @Before가 적용된 메서드는 모든 테스트 전에 매번 실행되는 메서드가 된다.

 

MockMvc는 말 그대로 '가짜 mvc'라고 생각하면 된다. 가짜로 URL과 파라미터 등을 브라우저에서 사용하는 것처럼 만들어서 Controller를 실행해 볼 수 있다. 

 

testList()는 MockMvcRequestBuilders라는 존재를 이용해서 GET 방식의 호출을 한다. 이후에는 BoardController의 getList()에서 반환된 결과를 이용해서 Model에 어떤 데이터들이 담겨 있는지 확인한다. Tomcat을 통해서 실행되는 방식이 아니므로 기존의 테스트 코드를 실행하는 것과 동일하게 실행한다.

 

testList()를 실행한 결과는 데이터베이스에 저장된 게시물들을 볼 수 있다.



![img](https://blog.kakaocdn.net/dn/l1kg3/btq4F7UIhl0/67LPs9TyQ8ix5smmtQkkyK/img.png)

오류가 뜬다면 아래와 같이 `pom.xml`에 수정한다.

```xml
<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
			<scope>provided</scope>
</dependency>
```





---

​		